[[2024-03-31]] #DBMS #Database #SQL

SQL is declarative. User tells the DBMS what answer they want, **NOT HOW** to get the answer. That said, there can be a big difference in performance based on plan is used.

This lecture focuses on the topic of **query optimization**.

### Query Optimization
At a high level, there are two categories of query optimization:
- **Heuristics/Rules**
	- Rewrite the query to remove stupid/inefficient things
	- These techniques may need to **examine catalog** (metadata), but they do not need to examine data
- **Cost-based Search**
	- Use a model to estimate the cost of different alternatives of executing a plan, generated by an engine
	- Evaluate multiple equivalent plans for a query and pick the one with the lowest cost
	- Used for **more complicated scenarios**

#### Architecture Overview

![[Pasted image 20240331212135.png|500]]

Parser is used to produce a **syntax tree** for the SQL query. The binder translates tables into **actual entities** in system. Then, it generates a **logical plan** in a straightforward fashion, pretty much like a query plan tree we've seen previously. The **tree rewriter** follows the **heuristics approach** and the **optimizer** uses the **cost-based approach**. Lastly, the optimizer returns a **physical plan**, which is a concrete plan that allows the system to execute the query.
- A [[7 DB Application, Security#^5365a4|prepared statement]] prepares a **physical plan** for the query, hence saving lots of time to go through this architecture again

```ad-summary
**Logical v.s. Physical Plans**

The optimizer generates a mapping of a **logical algebra expression** to the optimal equivalent physical algebra expression.
- Can be adjusted by the tree rewriter (heuristics)

Physical operators define a **specific execution strategy** using an access path.
- They can depend on the physical format of the data that they process (i.e., sorting, compression)

There is **NOT Always a 1:1 mapping** from logical to physical plan.
- E.g. one logical plan could be associated with multiple physical plans, like different join algorithms

```

We will mostly focus on query optimization on the **logical level** - heuristics or query rewriting.

The goal is to transform a logical plan into **an equivalent logical plan** using pattern matching rules to increase the **likelihood of enumerating the optimal plan** in the search. 
- Cannot compare plans because there is **NO cost model** but can "direct" a transformation to a preferred side

---
### Relational Algebra Equivalences
Two relational algebra expressions are **equivalent** if they **generate the same set of tuples**. The DBMS can identify better query plans **WITHOUT a cost model**. This is often called query rewriting.

#### Selections
One of the most common heuristics is **predicate pushdown**.

![[Pasted image 20240331213406.png|500]]

Here, it would be much faster if we select the corresponding tuples in `enrolled` first then join.

To generalize, we would prefer **breaking a complex predicate** into pieces and **push down these filters to perform as early as possible**: $$\sigma_{p_{1}\land p_{2}\land \cdots p_{n}}(R)\equiv\sigma_{p_{1}}(\sigma_{p_{2}}(\cdots \sigma_{p_{n}(R)}))$$
#### Joins
For joins, we have two rules:
- **Commutative**: $R \bowtie S \equiv S \bowtie R$
- **Associative**: $(R\bowtie S)\bowtie T \equiv R \bowtie (S \bowtie T)$

Trying out combinations of joins could be very costly - the number of different join orderings for an $n$ -way join is a Catalan Number ($4^{n}$). Hence, we would **NOT** use heuristics at joins but choose to go with a cost-based search.

#### Projections
We want to **perform them early to create smaller tuples** and **reduce intermediate results** (if duplicates are eliminated). In other words, **project out ALL attributes** except the ones requested or required (e.g., joining keys).

This does not concern **column store** due to [[13 Sorting & Aggregation#^52a82a|late materialization]].

![[Pasted image 20240331214836.png|500]]

---
### Logical Query Optimization 
Let's look at one simple example, combining the heuristics we've discussed previously. Imagine a query plan that looks like this. 

![[Pasted image 20240331223626.png|300]] 

To optimize this logically, we need to
1. **Decompose predicates into their simplest forms** to make it easier for the optimizer to move them around
2. Move the predicate to the **lowest applicable point** in the plan
3. Replace all Cartesian Products with inner joins using the **equijoin predicates**
4. **Eliminate redundant attributes** (early projection) before pipeline breakers to reduce materialization cost

---
### Nested Sub-queries
The DBMS treats nested sub-queries in the **where clause as functions** that take parameters and return a single value or set of values. Thus, it could be potentially very time-consuming to perform such operations

There are two approaches to solve this:
1. **Rewrite** to de-correlate and/or flatten them   
![[Pasted image 20240331225207.png|300]]

In the example above, we choose to flatten the nested query so that the outer query does not have to do a full join with the nested query when scanning a corresponding $S$ tuple.

2. **Decompose nested query** and **store result to temporary table**
	- For harder queries, the optimizer **breaks up queries into blocks** and then concentrates on one block at a time
	- Sub-queries are written to a temporary table that are **discarded after the query finishes**

![[Pasted image 20240331225421.png|300]]

In the example above, if we did not run the sub-query separately, we would need to run it for **EVERY tuple** in $S$.

---
### Expression Rewriting
An optimizer transforms a query's expressions (e.g., `WHERE` clause predicates) into the **optimal/minimal set of expressions**.

It is implemented using **if/then/else clauses** or a **pattern-matching rule engine**.
- Search for expressions that match a pattern
- When a match is found, rewrite the expression 
- Halt if there are no more rules that match

Examples include join eliminations, merging predicates, etc.

---
### Cost-based Search
Generate an estimate of the cost of executing a **particular query plan** for the current state of the database. We can use this in the search space to compare complexities of multiple alternatives.
- Estimates are only meaningful internally

There are two components:
1. Physical Cost 
	- Predict CPU cycles, I/O time, cache misses, RAM consumption, pre-fetching, etc
	- Heavily dependent on **hardware**, hard to estimate
	- Mostly seen in commercial system
1. Logical Costs
	- Estimate result sizes per operator
	- **Complexity of the operator algorithm** implementation
	- Number of sequential I/Os, number of random I/Os, number of arithmetics
	- Independent of the hardware and easy to do

For disk-based DBMS, the **number of disk accesses** will always dominate the execution time of a query.
- CPU costs are negligible
- Must consider sequential vs. Random I/O

This is easier to model if the DBMS has full control over **buffer management**.
